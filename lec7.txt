перед написанием кода функции нужно выделить на стеке необходимое количествво места, 
выровнять его на 16, и pop/push не делать, а писать в стек mov-ами


default rel он сам подставляет к адресам смещение и сегмент
почти ни в какую команду нельзя подставлять 64бит константы

операции e*-регистров обнуняют r-часть

записывать маленькие части можно сразу в e*

mov rcx, метка   работать не будет!


=======
Аппаратная поддержка синхронизации

можно делать транзакции

inc [rax] --- не атормарная операция!
она сотоит из 
    read
    inc
    write
если несколько потоков фигачат одновременно, то будут проблемы


mov eax, [...] --- не атомарная операция! читается 4 байта. можно прочитать 2 старых байта и 2 новых

есть префикс lock, который можно поставить перед некоторыми командами.
это означает, что команда будет выполнена атомарно
только команды арифметики, битовых операций и обмена

можно использовать только для команд, работающих с памятью

если lock поставить куда-то не туда, то всё сломается
ну как сломается. кинется warning

команда обмена xchg с памятью --- всегда атомарна

xadd - складывает два операнда, записывает 
xadd [x], eax:
    [x] = [x] + eax
    eax = [x]

cmpxchg [x], ecx:
    if [x] == eax
        [x] = ecx
    else 
        eax = [x]

cmpxchg8b, cmpxchg16b --- аналогично для регистровой пары/rрегистра
cmpxchg8b [x]
    if [x] == edx:eax
        [] = ecx:ebx
    else
        edx:eax = []

это было cas (compare and set)

задание:
dword f(dword *i, dword x)
{
    dword r = *i;
    *i -= x;
    return r;
}

решение:
mov ecx, [esp + 4]
mov eax, [esp + 8]
neg eax
lock xadd [ecx], eax
ret 8

задание:
dword f(dword *i, dword x)
{
    dword r = *i;
    *i &= x;
    return r;
}

рещение:

