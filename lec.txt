eax, ecx, edx --- портить
edp, ebx, eip, 

thiscall --- vusial studio, методы классов
можно перед функцией писать __cdecl или аналоги

указатель this передаётся в ecx

__pascal никому не нужен


беда! как вернуть из функции мегабайт данных?
на стек класть плохо. в кучу класть плохо.
в регистры хорошо. но не влазит ну никак.

Решение: вызывающий функцию сам даёт буфер, куда возвращать

X f(int a); // X --- большой тип. у нас __cdecl :

push a
push buffer
call f
add esp, 8

f:
...
mov ecx, [esp + 4]
mov [ecx], ...
mov eax, ecx
ret


__cdecl делает так:
push a
push buffer 
call f
add esp, 4

...
mov ecx, [esp + 4]
mov [ecx], ...
mov eax, ecx
ret 4

ааа, метод возвращает большую структуру! два скрытых параметра
в каком они порядке? а никто не знает, не договорились

разумнее первым передавать буфер на возвращающее значени --- gcc
microsoft-компиляторы, чтобы всем было плохо, делают наоборот

в WINAPI нет таких функций, которые возвращают больше двух регистров памяти

это были конвеции из 32-битного мира. 16- и 64- --- другие. В 64- их всего
две. но они уделывают эти по количеству геморроя. Весь мир, кроме винды ---
конвенция #1, винда --- #2.

__fastcall зависит от компилятора.


if (eax < 5)
	...1
else
	...2


cmp eax, 5
jae l1
	...1
jmp l2
l1:
	...2
l2:

Книжка: Зубков, ASM для чайников, DOS и UNIX


Пример посложнее:
if (eax < 5 && ebx)
	...1
else
	...2

cmp eax, 5
jae l1
test ebx,ebx ; проверка на 0. будет скомпилировано в более короткий код,
нежели test ebx, 0
jnz l1
	...1
	jmp l2
l1:
	...2
l2:



БУДЬТЕ АКУРАТНЫ ПРИ ОПТИМИЗАЦИЯХ!! Доверяйте только профайлеру! Не верьте в
книжки! "То, что написано на ASM --- быстро" --- ложь! Скорость зависит от
того, кто это пишет, а не от того, что это ассемблер

Ах да, if-ы должны быть ленивые

Пример: is_digit :: char -> bool
if (eax >= '0' && eax <= '9') ...

lea ecx, [eax - '0']
cmp ecx, '9' - '0'
ja l1 ; так как число без знака, то это работает
	...
l1:

офигеть! в два раза меньше условных переходов!
аналог в C: if ( (uint)(eax - '0') <= '9' - '0')


Теперь switch-case

switch (eax)
{
	case 1:
		...1
		break
	case 3:
	case 4:
		...2
	default:
		...3
}


table dd l3, l1, l3, l2, l2  // dd -- define dword

cmp eax, 4
ja l3
jmp dword [table + eax * 4]
l1:
	...1
	jmp l4
l2:
	...2
l3:
	...3
l4:

Всё просто, логично и понятно


Дальше, while

while (eax > 3)
	...


l2:
cmp eax, 3
jbe l1
...
jmp l2
l1:


do...while(eax > 3)

l1:
...
cmp eax, 3
ja l1

do...while явно же лучше!

можно переписать while, чтобы стало так же хорошо

cmp eax, 3
jbe l2
l1:
	...
	cmp eax, 3
	ja l1
l2:

или так
jmp l2
l1: ...
l2: 
	cmp eax, 3
	ja l1



тадааам, осталось только for

for (uint eax = 0; eax < 5; eax++)
	...


xor eax, eax
l1:
	...
	inc eax
	cmp eax, 5
	jb l1


а теперь наоборот!
mov eax, 5
l1:
	...
	dec eax
	cmp eax, 0
	ja l1


можно заменить cmp eax, 0 -> test eax, eax 
тогда ja l1 -> jnz l1

оптимизация 2:
dec ставит некоторые флаги. а именно, флаг нуля ставится. поэтому, test можно
просто выкинуть
итого:
l1:
	...
	dec eax
	jnz l1

однако, это немного не то, что хотелось бы. 5..1 вместо 4..0
как решить?
l1:
	...
	dec eax
	jnc l1 ; был ли перенос. хочется написать так, но dec не ставит флаг
	переноса. беда. надо писать sub eax, 1

Какой из всего этого можно сделать вывод? Итерирование вниз будет пободрее



